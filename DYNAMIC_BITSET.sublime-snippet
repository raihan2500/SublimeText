<snippet>
	<content><![CDATA[

template<typename BlockType = uint64_t>
struct DynBits {
  int n;
  vector<BlockType> bits;

  DynBits(int n = 0) : n(n) {
    bits.assign((n + (sizeof(BlockType)*8 - 1)) / (sizeof(BlockType)*8), 0);
  }

  struct reference {
    BlockType &ref;
    int pos;
    reference(BlockType &ref, int pos) : ref(ref), pos(pos) {}
    operator bool() const { return (ref >> pos) & 1ULL; }
    reference& operator=(bool val) {
      if (val) ref |= (BlockType(1) << pos);
      else ref &= ~(BlockType(1) << pos);
      return *this;
    }
    reference& flip() {
      ref ^= (BlockType(1) << pos);
      return *this;
    }
  };

  reference operator[](int idx) { return reference(bits[idx / (sizeof(BlockType)*8)], idx % (sizeof(BlockType)*8)); }
  bool operator[](int idx) const { return (bits[idx / (sizeof(BlockType)*8)] >> (idx % (sizeof(BlockType)*8))) & 1ULL; }

  void set() { for (auto &x : bits) x = ~BlockType(0); trim(); }
  void set(int pos) { bits[pos / (sizeof(BlockType)*8)] |= (BlockType(1) << (pos % (sizeof(BlockType)*8))); }

  void reset() { for (auto &x : bits) x = 0; }
  void reset(int pos) { bits[pos / (sizeof(BlockType)*8)] &= ~(BlockType(1) << (pos % (sizeof(BlockType)*8))); }

  void flip() { for (auto &x : bits) x = ~x; trim(); }
  void flip(int pos) { bits[pos / (sizeof(BlockType)*8)] ^= (BlockType(1) << (pos % (sizeof(BlockType)*8))); }

  bool test(int pos) const { return (*this)[pos]; }
  bool any() const { for (auto x : bits) if (x) return true; return false; }
  bool none() const { return !any(); }
  bool All() const {
    int sz = bits.size();
    for (int i = 0; i < sz; i++) {
      BlockType mask = ~BlockType(0);
      if (i == sz-1 && n % (sizeof(BlockType)*8)) mask = (BlockType(1) << (n % (sizeof(BlockType)*8)))-1;
      if ((bits[i] & mask) != mask) return false;
    }
    return true;
  }
  int count() const {
    int c = 0;
    for (auto &x : bits){
      if(sizeof(BlockType) == 8)c += __builtin_popcountll(x);
      else c += __builtin_popcountll((uint64_t(x & 0xFFFFFFFFFFFFFFFFULL)) + __builtin_popcountll(uint64_t(x >> 64)));
    } 
    return c;
  }
  int size() const { return n; }

  DynBits operator&(const DynBits &other) const { 
    DynBits res(n);
    for (int i = 0; i < (int)bits.size(); i++) res.bits[i] = bits[i] & other.bits[i];
    return res;
  }
  DynBits operator|(const DynBits &other) const { 
    DynBits res(n);
    for (int i = 0; i < (int)bits.size(); i++) res.bits[i] = bits[i] | other.bits[i];
    return res;
  }
  DynBits operator^(const DynBits &other) const { 
    DynBits res(n);
    for (int i = 0; i < (int)bits.size(); i++) res.bits[i] = bits[i] ^ other.bits[i];
    return res;
  }
  DynBits operator~() const {
    DynBits res(n);
    for (int i = 0; i < (int)bits.size(); i++) res.bits[i] = ~bits[i];
    res.trim();
    return res;
  }

  DynBits& operator&=(const DynBits &other) { for(int i=0;i<(int)bits.size();i++) bits[i]&=other.bits[i]; return *this; }
  DynBits& operator|=(const DynBits &other) { for(int i=0;i<(int)bits.size();i++) bits[i]|=other.bits[i]; return *this; }
  DynBits& operator^=(const DynBits &other) { for(int i=0;i<(int)bits.size();i++) bits[i]^=other.bits[i]; return *this; }

  DynBits operator<<(int k) const {
    DynBits res(n);
    int W = sizeof(BlockType)*8;
    int word = k / W, offset = k % W;
    int sz = bits.size();
    for (int i = sz-1; i >= 0; i--) {
      if (i-word < 0) continue;
      res.bits[i] |= bits[i-word] << offset;
      if (offset && i-word-1 >= 0) res.bits[i] |= bits[i-word-1] >> (W-offset);
    }
    res.trim();
    return res;
  }

  DynBits operator>>(int k) const {
    DynBits res(n);
    int W = sizeof(BlockType)*8;
    int word = k / W, offset = k % W;
    int sz = bits.size();
    for (int i = 0; i < sz; i++) {
      if (i+word >= sz) continue;
      res.bits[i] |= bits[i+word] >> offset;
      if (offset && i+word+1 < sz) res.bits[i] |= bits[i+word+1] << (W-offset);
    }
    res.trim();
    return res;
  }

  DynBits& operator<<=(int k) { return *this = (*this << k); }
  DynBits& operator>>=(int k) { return *this = (*this >> k); }

  string to_string() const {
    string s;
    for (int i = n-1; i >=0; i--) s.push_back(test(i)?'1':'0');
    return s;
  }

  friend std::ostream& operator << (std::ostream &os, const DynBits &x){return os << x.to_string();}

private:
  void trim() {
    int W = sizeof(BlockType)*8;
    if (n % W) bits.back() &= (BlockType(1) << (n % W)) - 1;
  }
};


]]></content>
	<tabTrigger>DYNAMIC_BITSET</tabTrigger>
	<scope>source.c++</scope>
</snippet>

